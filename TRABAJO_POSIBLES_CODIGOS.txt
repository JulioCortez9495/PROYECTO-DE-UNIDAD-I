C:\Program Files\CodeBlocks\MinGW\x86_64-w64-mingw32



#include <GL/glut.h>
#include <iostream>
#include <cmath>

using namespace std;

float centerX = 0.0f;
float centerY = 0.0f;
int radiusX = 80;
int radiusY = 50;
float rotation = 0.0f;

void putPixel(int x, int y)
{
    glVertex2i(x, y);
}

void rotatePoint(int& x, int& y, float angle)
{
    float rad = angle * M_PI / 180.0f;
    float cosA = cos(rad);
    float sinA = sin(rad);
    float xr = x * cosA - y * sinA;
    float yr = x * sinA + y * cosA;
    x = static_cast<int>(round(xr));
    y = static_cast<int>(round(yr));
}

void drawEllipseMidpoint(int cx, int cy, int rx, int ry, float angle = 0.0f)
{
    int x = 0;
    int y = ry;

    int rxSq = rx * rx;
    int rySq = ry * ry;

    int twoRxSq = 2 * rxSq;
    int twoRySq = 2 * rySq;

    int px = 0;
    int py = twoRxSq * y;

    glBegin(GL_POINTS);

    int p1 = rySq - (rxSq * ry) + (0.25 * rxSq);
    while (px < py)
    {
        int drawX = x;
        int drawY = y;
        rotatePoint(drawX, drawY, angle);

        putPixel(cx + drawX, cy + drawY);
        putPixel(cx - drawX, cy + drawY);
        putPixel(cx + drawX, cy - drawY);
        putPixel(cx - drawX, cy - drawY);

        x++;
        px += twoRySq;

        if (p1 < 0)
            p1 += rySq + px;
        else
        {
            y--;
            py -= twoRxSq;
            p1 += rySq + px - py;
        }
    }

    int p2 = rySq * (x + 0.5) * (x + 0.5) + rxSq * (y - 1) * (y - 1) - rxSq * rySq;
    while (y >= 0)
    {
        int drawX = x;
        int drawY = y;
        rotatePoint(drawX, drawY, angle);

        putPixel(cx + drawX, cy + drawY);
        putPixel(cx - drawX, cy + drawY);
        putPixel(cx + drawX, cy - drawY);
        putPixel(cx - drawX, cy - drawY);

        y--;
        py -= twoRxSq;

        if (p2 > 0)
            p2 += rxSq - py;
        else
        {
            x++;
            px += twoRySq;
            p2 += rxSq - py + px;
        }
    }

    glEnd();
}

void display()
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1.0f, 1.0f, 1.0f);

    drawEllipseMidpoint((int)round(centerX), (int)round(centerY), radiusX, radiusY, rotation);

    glFlush();
}

void reshape(int width, int height)
{
    glViewport(0, 0, width, height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    float aspectRatio = (float)width / (float)height;
    if (width >= height)
        glOrtho(-200.0 * aspectRatio, 200.0 * aspectRatio, -200.0, 200.0, -1.0, 1.0);
    else
        glOrtho(-200.0, 200.0, -200.0 / aspectRatio, 200.0 / aspectRatio, -1.0, 1.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key)
    {
        case 27:
            exit(0);
            break;
        case 'r':
        case 'R':
            centerX = 0.0f;
            centerY = 0.0f;
            radiusX = 80;
            radiusY = 50;
            rotation = 0.0f;
            glutPostRedisplay();
            break;
        case '+':
            radiusX += 5;
            radiusY += 3;
            glutPostRedisplay();
            break;
        case '-':
            if (radiusX > 5) radiusX -= 5;
            if (radiusY > 3) radiusY -= 3;
            glutPostRedisplay();
            break;
        case 'q':
        case 'Q':
            rotation += 15;
            if (rotation >= 360) rotation -= 360;
            glutPostRedisplay();
            break;
        case 'e':
        case 'E':
            rotation -= 15;
            if (rotation < 0) rotation += 360;
            glutPostRedisplay();
            break;
    }
}

void init()
{
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glPointSize(2.0f);
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(800, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow(" 'LA ELIPSE' ");

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);

    init();

    glutMainLoop();

    return 0;
}



//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
RECTAS

#include <GL/glut.h>
#include <iostream>
#include <cmath>

using namespace std;

int x0_line, y0_line, x1_line, y1_line;
bool firstClick = true;

enum Algorithm { NONE, DIRECT, DDA };
Algorithm currentAlgorithm = NONE;

// ====== Algoritmo: Método Directo (y = mx + b) ======
void drawLineDirect(int x0, int y0, int x1, int y1)
{
    glBegin(GL_POINTS);
    if (x0 == x1) // Línea vertical
    {
        int yStart = min(y0, y1);
        int yEnd = max(y0, y1);
        for (int y = yStart; y <= yEnd; y++)
            glVertex2i(x0, y);
    }
    else
    {
        float m = float(y1 - y0) / (x1 - x0);
        float b = y0 - m * x0;

        int xStart = min(x0, x1);
        int xEnd = max(x0, x1);

        for (int x = xStart; x <= xEnd; x++)
        {
            float y = m * x + b;
            glVertex2i(x, round(y));
        }
    }
    glEnd();
}

// ====== Algoritmo: DDA (Incremental) ======
void drawLineDDA(int x0, int y0, int x1, int y1)
{
    int dx = x1 - x0;
    int dy = y1 - y0;

    int steps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);

    float xInc = dx / (float)steps;
    float yInc = dy / (float)steps;

    float x = x0;
    float y = y0;

    glBegin(GL_POINTS);
    for (int i = 0; i <= steps; i++)
    {
        glVertex2i(round(x), round(y));
        x += xInc;
        y += yInc;
    }
    glEnd();
}

// ====== Dibuja ejes ======
void drawAxes()
{
    glColor3f(0.5f, 0.5f, 0.5f);
    glBegin(GL_LINES);
    glVertex2i(-400, 0);
    glVertex2i(400, 0);
    glVertex2i(0, -300);
    glVertex2i(0, 300);
    glEnd();
}

// ====== Dibujo principal ======
void display()
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1, 1, 1);

    drawAxes();

    if (currentAlgorithm == DIRECT)
        drawLineDirect(x0_line, y0_line, x1_line, y1_line);
    else if (currentAlgorithm == DDA)
        drawLineDDA(x0_line, y0_line, x1_line, y1_line);

    glFlush();
}

// ====== Mouse para capturar puntos ======
void mouse(int button, int state, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
    {
        int winWidth = glutGet(GLUT_WINDOW_WIDTH);
        int winHeight = glutGet(GLUT_WINDOW_HEIGHT);

        int xGL = x - winWidth / 2;
        int yGL = (winHeight / 2) - y;

        if (firstClick)
        {
            x0_line = xGL;
            y0_line = yGL;
            firstClick = false;
        }
        else
        {
            x1_line = xGL;
            y1_line = yGL;
            firstClick = true;
            glutPostRedisplay();
        }
    }
}

// ====== Menú de selección ======
void menu(int option)
{
    switch (option)
    {
    case 1:
        currentAlgorithm = DIRECT;
        break;
    case 2:
        currentAlgorithm = DDA;
        break;
    case 3:
        currentAlgorithm = NONE;
        glutPostRedisplay();
        break;
    case 9:
        exit(0);
    }
    glutPostRedisplay();
}

void createMenu()
{
    glutCreateMenu(menu);
    glutAddMenuEntry("Recta - Método Directo", 1);
    glutAddMenuEntry("Recta - Método DDA", 2);
    glutAddMenuEntry("Limpiar", 3);
    glutAddMenuEntry("Salir", 9);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

// ====== Inicialización de OpenGL ======
void init()
{
    glClearColor(0, 0, 0, 1);
    glColor3f(1, 1, 1);
    glPointSize(2);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-400, 400, -300, 300);
}

// ====== Función principal ======
int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(800, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Lineas: Metodo Directo y DDA - OpenGL");

    init();
    createMenu();

    glutDisplayFunc(display);
    glutMouseFunc(mouse);

    glutMainLoop();
    return 0;
}


---------------------------------------------------------------------
PLANTILLA MENU 
-------------------------------------------------------------------

#include <GL/glut.h>
#include <iostream>

// IDs de los menús
enum MenuOpciones {
    RECT_LINEA_DIRECTA = 1,
    RECT_LINEA_DDA,
    CIRCULO_PM,
    ELIPSE_PM,
    COLOR_ROJO,
    COLOR_VERDE,
    COLOR_AZUL,
    GROSOR_1,
    GROSOR_3,
    LIMPIAR
};

void menuHandler(int opcion) {
    switch (opcion) {
        case RECT_LINEA_DIRECTA:
            std::cout << "Dibujar recta (Directo)\n";
            break;
        case RECT_LINEA_DDA:
            std::cout << "Dibujar recta (DDA)\n";
            break;
        case CIRCULO_PM:
            std::cout << "Dibujar círculo (Punto Medio)\n";
            break;
        case ELIPSE_PM:
            std::cout << "Dibujar elipse (Punto Medio)\n";
            break;
        case COLOR_ROJO:
            std::cout << "Color cambiado a rojo\n";
            break;
        case COLOR_VERDE:
            std::cout << "Color cambiado a verde\n";
            break;
        case COLOR_AZUL:
            std::cout << "Color cambiado a azul\n";
            break;
        case GROSOR_1:
            std::cout << "Grosor 1 px\n";
            break;
        case GROSOR_3:
            std::cout << "Grosor 3 px\n";
            break;
        case LIMPIAR:
            std::cout << "Lienzo limpiado\n";
            glClear(GL_COLOR_BUFFER_BIT);
            glutPostRedisplay();
            break;
    }
}

void initMenu() {
    // Submenú Dibujo
    int submenuDibujo = glutCreateMenu(menuHandler);
    glutAddMenuEntry("Recta (Directo)", RECT_LINEA_DIRECTA);
    glutAddMenuEntry("Recta (DDA)", RECT_LINEA_DDA);
    glutAddMenuEntry("Círculo (Punto Medio)", CIRCULO_PM);
    glutAddMenuEntry("Elipse (Punto Medio)", ELIPSE_PM);

    // Submenú Color
    int submenuColor = glutCreateMenu(menuHandler);
    glutAddMenuEntry("Rojo", COLOR_ROJO);
    glutAddMenuEntry("Verde", COLOR_VERDE);
    glutAddMenuEntry("Azul", COLOR_AZUL);

    // Submenú Grosor
    int submenuGrosor = glutCreateMenu(menuHandler);
    glutAddMenuEntry("1 px", GROSOR_1);
    glutAddMenuEntry("3 px", GROSOR_3);

    // Menú principal
    int menuPrincipal = glutCreateMenu(menuHandler);
    glutAddSubMenu("Dibujo", submenuDibujo);
    glutAddSubMenu("Color", submenuColor);
    glutAddSubMenu("Grosor", submenuGrosor);
    glutAddMenuEntry("Limpiar lienzo", LIMPIAR);

    // Activar menú en botón derecho
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(800, 600);
    glutCreateWindow("CAD 2D - Menú FreeGLUT");

    initMenu(); // inicializa menú

    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}

//////////////////////////////////////////////////////////////////
CIRCUNFERENCIA 
/////////////////////////////////////////////////////////////////
#include <GL/glut.h>
#include <cmath>
#include <iostream>

using namespace std;

int centerX, centerY, radius;
bool waitingForRadius = false;

enum Mode { NONE, CIRCLE };
Mode currentMode = NONE;

// ===== Dibuja círculo con algoritmo del punto medio =====
void drawCircleMidpoint(int xc, int yc, int r)
{
    int x = 0;
    int y = r;
    int p = 1 - r;

    glBegin(GL_POINTS);
    while (x <= y)
    {
        // Simetría por octantes
        glVertex2i(xc + x, yc + y);
        glVertex2i(xc - x, yc + y);
        glVertex2i(xc + x, yc - y);
        glVertex2i(xc - x, yc - y);
        glVertex2i(xc + y, yc + x);
        glVertex2i(xc - y, yc + x);
        glVertex2i(xc + y, yc - x);
        glVertex2i(xc - y, yc - x);

        if (p < 0)
            p += 2 * x + 3;
        else
        {
            p += 2 * (x - y) + 5;
            y--;
        }
        x++;
    }
    glEnd();
}

// ===== Dibuja los ejes X e Y =====
void drawAxes()
{
    glColor3f(0.5f, 0.5f, 0.5f);
    glBegin(GL_LINES);
        glVertex2i(-400, 0);
        glVertex2i(400, 0);
        glVertex2i(0, -300);
        glVertex2i(0, 300);
    glEnd();
}

// ===== Función display =====
void display()
{
    glClear(GL_COLOR_BUFFER_BIT);
    drawAxes();

    if (currentMode == CIRCLE && !waitingForRadius)
    {
        glColor3f(1.0f, 1.0f, 1.0f); // blanco
        drawCircleMidpoint(centerX, centerY, radius);
    }

    glFlush();
}

// ===== Función mouse para definir centro y radio =====
void mouse(int button, int state, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN && currentMode == CIRCLE)
    {
        int winWidth = glutGet(GLUT_WINDOW_WIDTH);
        int winHeight = glutGet(GLUT_WINDOW_HEIGHT);

        int xGL = x - winWidth / 2;
        int yGL = (winHeight / 2) - y;

        if (!waitingForRadius)
        {
            centerX = xGL;
            centerY = yGL;
            waitingForRadius = true;
            cout << "Centro: (" << centerX << ", " << centerY << ")" << endl;
        }
        else
        {
            int dx = xGL - centerX;
            int dy = yGL - centerY;
            radius = (int)sqrt(dx * dx + dy * dy);
            waitingForRadius = false;

            cout << "Radio: " << radius << endl;
            glutPostRedisplay();
        }
    }
}

// ===== Menú contextual con botón derecho =====
void menu(int option)
{
    switch (option)
    {
        case 1: // Dibujar círculo
            currentMode = CIRCLE;
            waitingForRadius = false;
            break;
        case 2: // Limpiar
            currentMode = NONE;
            glutPostRedisplay();
            break;
        case 9:
            exit(0);
    }
}

void createMenu()
{
    glutCreateMenu(menu);
    glutAddMenuEntry("Dibujar Círculo (Punto Medio)", 1);
    glutAddMenuEntry("Limpiar", 2);
    glutAddMenuEntry("Salir", 9);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

// ===== Inicialización de OpenGL =====
void init()
{
    glClearColor(0.0, 0.0, 0.0, 1.0);   // Fondo negro
    glColor3f(1.0, 1.0, 1.0);           // Color blanco por defecto
    glPointSize(2.0);                  // Grosor de punto
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-400, 400, -300, 300);  // Sistema de coordenadas
}

// ===== Función principal =====
int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(800, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Círculo - Método Punto Medio (Mouse + Menú)");

    init();
    createMenu();

    glutDisplayFunc(display);
    glutMouseFunc(mouse);

    glutMainLoop();
    return 0;
}




































